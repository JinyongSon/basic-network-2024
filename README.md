# basic-network2024
2024년 IoT개발자과정 네트워크 통신 리포지토리

# basic-network-2024
2024년 IoT개발자과정 네트워크 통신 리포지토리


## 1일차

- 리눅스
    - 파일 입출력(LOW-level File Access)
    - 파일 디스크립터(File Descriptor)
    - 파일 열기 (open)
        - path : 파일 이름을 나타내는 문자열의 주소 값 전달.
        - flag : 파일의 오픈 모드 정보 전달
    
    - 파일 닫기 (close)
        - fd : 닫고자 하는 파일 또는 소켓의 파일 디스크립터 전달.

    - 파일에 데이터 쓰기 (writh)
        - fd : 데이터 전송대상을 나타내는 파일 디스크립터 전달.
        - buf : 전송할 데이터가 저장된 버퍼의 주소 값 전달.
        - nbytes : 전송할 데이터의 파이트 수 전달.

    - 파일에 저장된 데이터 읽기(read)
        - fd : 데이터 수신대상을 나타내는 파일 디스크립터 전달
        - buf : 수신한 데이터를 저장할 버퍼의 주소 값 전달
        - nbytes : 수신할 최대 바이트 수 전달

- 프로토콜
    - 소켓의 생성
        - domain : 소켓이 사용할 프로토콜 체계(Protocol Family)정보 전달
        - type : 소켓의 데이터 전송방식에 대한 정보 전달.
        - protocol : 두컴퓨터간 통신에 사용되는 프로토콜 정보 전달

    - 프로토콜 체계
        - PF-INET : IPv4 인터넷프로토콜 체계
        - PF_INET6 : IPV6 인터넷 프로토콜 체계
        - PF_LOCAL : 로컬 통신을 위한 UNIX 프로토콜 체계
        - PF_PACKET : Low Level 소켓을 위한 프로토콜 체계
        - PF_IPX : IPX 노벨 프로토콜 체계

    - 소켓의 타입
        - 연결지향형 소켓(TCP) 
            - 중간에 데이터가 소멸되지 않는다.
            - 전송 순서대로 데이터가 수신된다.
            - 전송되는 데이터의 경계(Boundary)가 존재하지 않는다. 

        - 비 연결지향형 소켓 (UDP)
            - 전송된 순서에 상관없이 가장 빠르게 전송을 지향한다.
            - 전송된 데이터는 손실의 우려가 있고, 파손의 우려가 있다.
            - 전송되는 데이터의 경계(Boundary)가 존재한다.
            - 한번에 전송할 수 있는 데이터의 크기가 제한된다.

    - IP주소와 PORT번호
        - 인터넷 주소(Inernet Address)
            - IPv4(Internet Protocol version4)  4바이트 주소체계
            - IPv6(Internet Protocol version6)  16바이트 주소체계

    - 클래스 별 네트워크 주소와 호스트 주소의 경계
        - 클래스 A의 첫 번째 바이트 범위 : 0이상 127이하  /  첫 번째 빝트는 항상 0으로 시작
        - 클래스 B의 첫 번째 바이트 범위 : 128이상 191이하  /  첫 두 비트는 항상 10으로 시작
        - 클래스 C의 첫 번째 바이트 범위 : 192이상 233이하  /  첫 세비트는 항상 110으로 시작

    - 주소정보의 표현
        - POSIX(Portable Operating System Interface)은 이식 가능한 운영 체제 인터페이스의 약자로,
          UNIX 운영 체제 호환성을 위한 표준 규격을 정의한 것입니다.
          POSIX는 다양한 운영 체제 간의 호환성을 보장하기 위해 IEEE가 개발했으며,
          다음과 같은 주요 구성 요소를 포함합니다:

        - 파일 시스템: 파일 및 디렉터리 조작에 관한 표준 인터페이스.
        - 프로세스 관리: 프로세스 생성, 제어, 종료 등에 관한 인터페이스.
        - 스레드: 멀티스레딩을 지원하기 위한 표준 인터페이스.
        - 입출력(I/O): 파일, 장치, 네트워크 소켓 등의 입출력 처리를 위한 표준 규격.
        - 유틸리티: 쉘 및 명령어 인터프리터, 시스템 명령어 및 유틸리티의 표준.

    - 구조체 sockaddr_in 멤버
        - 멤버 sin_family
            - AF_INET : IPv4 인터넷 프로토콜에 적용하는 주소체계
            - AF_INET6 : IPv6 인터넷 프로토콜에 적용하는 주소체계
            - AF_LOCAL : 로컬 통신을 위한 유닉스 프로토콜의 주소체계

        - 멤버 sin_port : 16비트 PORT번호 저장 / PORT 번호를 저장한다는 사실 보다 네트워크 바이트 
                          순서로 저장해야 한다는 사실이 더 중요하다.
        - 멤버 sin_addr : 32비트 IP주소정보 저장 / 네트워크 바이트 순서대로 저장하며 구조체 
                          in_addr도 함께 살펴봐야 한다.
        - 멤버 sin_zero : 구조체(struct sockaddr_in)에서 사용되는 멤버입니다. 이 멤버는 구조체의 
                          크기를 다른 주소 구조체와 맞추기 위해 사용되는 패딩 공간으로,
                          실제 데이터는 포함되지 않고 sin_zero는 보통 8바이트 크기의 배열임, 반드시 0으로 채워야 함.

## 2일차

- 인터넷 주소의 초기화
    ```c
    struct sockaddr_in addr; 
    char *serv_ip = "211.217.168.13";   // IP주소 문자열 선언
    char *serv_port = "9190";           // PORT번호 문자열 선언
    memset(&addr, 0, sizeof(addr));     // 구조체 변수 addr의 모든 멤버 0으로 초기화
    addr.sin_family = AF_INET;          // 주소체계 지정
    addr.sin_addr.s_addr = inet_addr(serv_ip);  // 문자열 기반의 IP 주소 초기화
    addr.sin_port = htons(atoi(serv_port));     // 문자열 기반의 PORT번호 초기화
    ```

- TCP/IP 프로토콜 스택
    - 
## 3일차

- connected UDP 소켓, unconnected UDP 소켓
    - sendto 함수 호출을 통한 데이터 전송
        - 1단계 UDP 소켓에 목적지의 IP와 PORT번호 등록
        - 2단계 데이터 전송
        - 3단계 UDP 소켓에 등록된 목적지 정보 삭제

    - connected UDP 소켓 생성
        ```
        sock=socket(PF_INET, SOCK_DGRAM, 0);
        memset(&adr, 0, sizeof(adr));
        adr.sin_family = AF_INET;
        adr.sin_addr.s_addr = ......;
        adr.sin_port = ........;
        connect(sock, (struct sockaddr*)&adr, sizeof(adr))
        ```

- 소켓의 연결종료
    - 소켓과 스트림(Stream)
    - shutdown 함수
        - SHUT_RD  :  입력 스트림 종료
        - SHUT_WR  :  출력 스트림 종료
        - SHUT_RDWR  :  입출력 스트림 종료
    - Half-close

- 도메인 이름과 인터넷 주소
    - TCP 기반의 Half-close
        - Domain Name System
            - DNS 서버
            - 도메인 이름을 이용해서 IP주소 얻어오기
                - h_name
                - h_aliases
                - h_addrtype
                - h_length
                - h_addr_list
        - IP주소를 이용해서 도메인 정보 얻어오기
            - gethostbyname


- 소켓의 다양한 옵션
    - 소켓의 옵션과 입출력 버퍼의 크기
        - 소켓의 다양한 옵션
        - getsockopt & setsockopt
        - SO_SNDBUF & SO_RCVBUF

    - SO_REUSEADDR
        - 주소할당 에러(Binding Error) 발생
        - Time-wait 상태
        - 주소의 재할당

    - TCP_NODELAY
        - Nagle 알고리즘
        - Nagle 알고리즘의 중단

- 멀티프로세스 기반의 서버구현
    - 프로세서의 이해와 활용
        - 다중접속 서버의 구현방법들
            - 멀티프로세스 기반 서버 : 다수의 프로세스를 생성하는 방식으로 서비스 제공
            - 멀티플렉싱 기반 서버 : 입출력 대상을 묶어서 관리하는 방식으로 서비스 제공
            - 멀티쓰레딩 기반 서버 : 클라이언트의 수만큼 쓰레드를 생성하는 방식으로 서비스 제공

        - fock 함수
            - 부모 프로세스 : fork 함수의 반환 값은 자식 프로세스의 ID
            - 자식 프로세스 : FORK 함수의 반환 값은 0

- 프로세스 & 좀비(Zombie)프로세스
    - 좀비(Zombie)프로세스 생성이유
        - 인자를 전달하면서 exit를 호출하는 경우
        - main 함수에서 return문을 싱행하면서 값을 반환하는 경우

## 4일차
- 좀비 프로세스의 소멸 : wait 함수의 사용
    - WIFEXITED : 자식 프로세스가 정상 종료한 경우 '참(true)'를 반환 한다.
    - WEXITSTATUS : 자식 프로세서의 전달 값을 반환한다.

- 시그널 핸들링
    - SIGALRM : alarm 함수호출을 통해서 등록된 시간이 된 상황
    - SIGINT : CTRL + C가 입력된 상황
    - SIGCHLD : 자식 프로세스가 종료된 상황
        - signal(SIGCHLD, mychild), signal(SIGALRM, timeout);, signal(SIGINT, keycontorol);
    - sigaction
        - sa_handler, sa_mask, sa_flags

- 멀티태스킹 기반의 다중접속 서버
    - 프로세스 기반의 다중접속 서버의 구현 모델(fork)
        - 1. 에코서버(부모 프로세스)는 accept 함수호출을 통해서 연결요청을 수락한다.
        - 2. 이때 얻게 되는 소켓의 파일 디스크리버를 자식프로세스를 생성해서 넘겨준다.
        - 3. 자식 프로세스는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공 한다.

- 프로세스간 통신
    - 파일을 통한 통신: 프로세스는 파일을 통해 데이터를 주고받을 수 있습니다. 이는 많은 운영 체제에서 지원되는 간단하고 효율적인 방법입니다.
    - 파이프: 단방향 또는 양방향으로 데이터를 전송할 수 있는 파이프(pipe)를 사용하여 프로세스 간에 통신할 수 있습니다. 이는 리눅스 및 유닉스 시스템에서 널리 사용됩니다.
    - 소켓: 네트워크를 통해 데이터를 전송하는 데 사용되는 소켓은 프로세스 간 통신을 위한 강력한 방법입니다. TCP/IP 소켓은 인터넷을 통한 통신에 주로 사용됩니다.
    - 메시지 큐: 메시지 큐를 사용하여 프로세스 간에 데이터를 전송할 수 있습니다. 이는 다양한 운영 체제에서 지원되며, 다른 프로세스에 메시지를 보낼 수 있습니다.
    - 공유 메모리: 공유 메모리를 사용하면 여러 프로세스가 동일한 메모리 공간에 접근하여 데이터를 공유할 수 있습니다. 이는 매우 빠른 통신을 제공하지만 조심스럽게 사용해야 합니다.

- IO 멀티플렉싱
    - IO 멀티플렉싱은 단일 프로세스가 여러 개의 입출력 작업을 동시에 처리할 수 있도록 하는 기술이고,
      주로 네트워크 프로그래밍이나 파일 입출력에서 사용됩니다. 다음은 IO 멀티플렉싱의 주요 개념과 장점을 설명한 것입니다:

        - 단일 스레드 환경: IO 멀티플렉싱은 단일 스레드에서 여러 개의 IO 작업을 처리할 수 있도록 합니다.
          이는 멀티 스레드를 사용하는 것보다 적은 자원을 사용하고 더 효율적으로 작업을 수행할 수 있습니다.

        - 이벤트 기반 처리: IO 멀티플렉싱은 주로 이벤트 기반의 프로그래밍 모델과 함께 사용됩니다. 
          입출력 작업이 완료되었을 때 발생하는 이벤트를 감지하고 처리함으로써 비동기적으로 작업을 수행할 수 있습니다.

        - select(), poll(), epoll(): 이러한 함수들은 다양한 플랫폼에서 IO 멀티플렉싱을 구현하는 데 사용됩니다. 
          select는 가장 오래된 방법으로, poll과 epoll은 보다 효율적인 대안으로 각각 다른 운영 체제에서 사용됩니다.

        - 비동기 소켓 프로그래밍: 네트워크 프로그래밍에서 IO 멀티플렉싱은 비동기 소켓을 통해 여러 클라이언트와 동시에 통신할 수 있도록 합니다.
          이를 통해 블로킹되지 않고 여러 연결을 처리할 수 있습니다.

        - 사용 사례: 대규모 웹 서버나 채팅 애플리케이션과 같이 동시에 많은 연결을 처리해야 하는 경우에 IO 멀티플렉싱은 매우 유용합니다.
          또한 파일 입출력 작업에서도 여러 파일을 동시에 처리할 때 유용하게 사용됩니다.
        